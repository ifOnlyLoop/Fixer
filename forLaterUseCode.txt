

/*
void ObjFile::triangulation(std::vector<int>& FaceVertexArg,int mode=0)
{
    // Declare Mesh Pivot 
    int pivot = FaceVertexArg[0];
    // temp face datatype
    Face tempFace;
    // Size of the Polygon "n"
    int argSize = FaceVertexArg.size();
    for (int i = 1; i < argSize-1; i++)
    {
        tempFace.push
        (
            pivot,
            FaceVertexArg[i],
            FaceVertexArg[i + 1]
        );
        if (i & mode)
            subDivision(tempFace);
        else
            faceList.push_back(tempFace);
    }
}

// trangulate
void ObjFile::subDivision(Face& TriF)
{
    
    /* Equations
     * #1: uV1 + vV2 + wV3 = p(x,y,z) 
     * #2: u   + v   + w   = 1        
     *
        
    // Extract Segement Points
    vec3
        pivot = vertexList[TriF[2]]
        + u * (vertexList[TriF[0]] - vertexList[TriF[2]])
        + v * (vertexList[TriF[1]] - vertexList[TriF[2]]);

    // Add to File Vertex List
    Vertex TriV;
    TriV.push(pivot);
    // Add to File Vertex List
    vertexList.push_back(TriV);
    // Get Pivot Index in the Vertex List
    int j = vertexList.size() - 1,
        z = TriF.size();
    // Push SubDivided Faces to Face List 
    for (int i = 0; i < z; i++)
        faceList.push_back(Face(j, TriF[i], TriF[(i + 1) % z]));
}

*/

// over load with segments (constrain) segment
/*
void ObjFile::subDivision(Face& TriF)
{

     * Equations
     * #1: uV1 + vV2 + wV3 = p(x,y,z)
     * #2: u   + v   + w   = 1
     *

     // Extract Segement Points
vec3
pivot1 = vertex[TriF[2]]
+ u * (vertex[TriF[0]] - vertex[TriF[2]])
+ v * (vertex[TriF[1]] - vertex[TriF[2]]);

u = 0.4f;
v = 0.1f;

vec3
pivot2 = vertex[TriF[2]]
+ u * (vertex[TriF[0]] - vertex[TriF[2]])
+ v * (vertex[TriF[1]] - vertex[TriF[2]]);

// Add to File Vertex List
Vertex TriV1, TriV2;

TriV1.push(pivot1);
vertex.push_back(TriV1);
int i = vertex.size() - 1;

// sub Segement start
TriV2.push(pivot2);
vertex.push_back(TriV2);
int j = vertex.size() - 1;

vec3 parallelEdge = pivot1 - pivot2;
float cosValue = 0, tempCos = 0;
int k = 0, z = TriF.size();

for (int r = 0; r < z; r++)
{
    tempCos = fabs(parallelEdge * (vertex[TriF[r]] - vertex[TriF[(r + 1) % z]])) //vertex[(i)])) //
        / (
            norm(parallelEdge) *
            norm(vertex[TriF[r]] - vertex[(r + 1) % z])
            );

    if (tempCos - cosValue > 0.0f)
    {
        cosValue = tempCos;
        k = (r + 2) % z;//TriF[r];
    }
}

//face.push_back(Face(i, TriF[0], TriF[1]));
//sub Segment end

std::vector<int> divFace(4, 0);
int
iClosest = TriF[(k + 1) % z],
jClosest = TriF[(k + 2) % z];

if (dist(vertex[i], vertex[TriF[(k + 1) % z]]) <
    dist(vertex[i], vertex[TriF[(k + 2) % z]]))

    std::swap(iClosest, jClosest);

divFace[0] = i;
divFace[1] = iClosest;
divFace[2] = jClosest;
divFace[3] = j;

triangulation(divFace, 0);

//face.push_back(Face(i, j, TriF[k]));
//face.push_back(Face(i, iClosest, TriF[k]));
//face.push_back(Face(j, jClosest, TriF[k]));

divFace.clear();
}*/